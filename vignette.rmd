---
title: "Fieldwork App Vignette"
author: "Nicholas Manna"
date: "6/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## Introduction and Resources

This document gives an overview of the back-end of the MARS Fieldwork Shiny app, and the reactive interactions between user-interface (UI), server, and different modules and tabs. I recommend perusing the following resources prior to digging into this document: 

[Introduction tutorial](https://shiny.rstudio.com/tutorial/)

[Fieldwork App GitHub Repo](https://github.com/taywater/shiny-fieldwork)

[Modularization](https://shiny.rstudio.com/articles/modules.html)

[PWD RStudio R blog – for RSConnect publishing](http://pwdrstudio/pwd-R-blog/public/)

[Shinyjs – this one’s easy](https://deanattali.com/shinyjs/)

[db Pool (easier than it seems)](https://shiny.rstudio.com/articles/pool-basics.html)

[datatable (DT)](https://rstudio.github.io/DT/)

[reactable](https://glin.github.io/reactable/)

Each module contains a UI and a Server function. These functions are used in app.R. In app.R, settings are created, database connections are set, and universal variables are queried, including those that are used in selectInputs (like SMP IDs). Then, the files that contain modules are sourced, and app.R has it's own UI and server functions, as well as a `runApp` function. The UI and server functions from the modules are called here, and function arguments include the aforementioned universal variables, database connection, and other modules' return values. 

## Modules of the Fieldwork App

The Fieldwork App consists of several modules, all passing or receiving information from at least one other module. These interactions are shown in the web below; for example, the Special Investigations module sends information to the Deploy Sensor module, but does not receive information from any other modules. While the "Deploy" module is the Fieldwork App's visual hub, the "Collection Calendar" module is the landing page. Routine interactions with the app often start in Collection Calendar and go elsewhere.


![](module_web.png)

Collection Calendar contains a table view with relevant info for the fieldwork team. Clicking a row in this table view sends the user to Deploy, with the deployment info from that row prepopulated in the Deploy UI. There are several steps that happen within Collection Calendar's server function to get there, and some that happen in Deploy's server function. We will examine these steps one at a time.

### Step 1: Collection Calendar UI - Create selectable output object

Collection Calendar's UI function is shown below. TabPanels are in a list so that they can be worked with more easily in app.R. The sidebarPanel separates the input controls from the mainPanel's datatable. The `DTOutput` function creates a reactive output variable, here named `collection`. It also creates an input variable, by default named `tableID_rows_selected` (e.g., `collection_rows_selected` here).


```{r collection_UI, eval = FALSE}

collection_calendarUI <- function(id, label = "collection_calendar"){
  ns <- NS(id)
  useShinyjs()
  
  #create a tabPanel for each tab
  list(
    tabPanel("Collection Calendar", value = "calendar_tab", 
             titlePanel("Collection Calendar"), 
             useShinyjs(), #this needs to be called anywhere in the UI to use other Shinyjs() functions
             sidebarPanel(
               selectInput(ns("property_type"), "Property Type", 
                           choices = c("All" = .5, "Public" = 1, "Private" = 0)),
               ... #Several more selectInputs elided for brevity
             ), 
             mainPanel(
               DTOutput(ns("collection"))
             )
    ), 
    tabPanel("Future Deployments", value = "future_tab", 
             
             titlePanel("Future Deployments"), 
                reactableOutput(ns("future")), 
             downloadButton(ns("download_future"), "Download Future Deployments")
    )
  )
  
}

```

![](cc_still.png)

### Step 2: Collection Calendar Server - Configure selectable output object

Next, in Collection Calendar's server function, the datatable object `output$collection` is created with argument `selection = "single"`. This allows the user to select one row at a time; when the user does, the numeric index of the selected row is assigned to the reactive value`input$collection_rows_selected`.

```{r collection_server, eval=FALSE}

output$collection <- renderDT(
        DT::datatable(
          rv$collect_table(), 
          selection = "single", 
          style = 'bootstrap', 
          class = 'table-responsive, table-hover', 
          options = list(scroller = TRUE, 
                         scrollX = TRUE, 
                         scrollY = 550, 
                         order = list(8, 'asc')), 
          rownames = FALSE) %>%
          formatStyle(
            '80% Full Date',
            backgroundColor = styleInterval(lubridate::today(), c('yellow', 'transparent')), 
            color = 'black'
          ) %>%
          ... #More functions to style table cells elided for brevity
      )

```

### Step 3: Collection Calendar Server - Observe selectable output object's corresponding input value

The next step, also within Collection Calendar's server function, is to observe `input$collection_rows_selected` for changes. When a row is selected, that value is updated. This performs two actions: 

1. Update a reactive value `deploy_refresh`, that will instruct Deploy to update itself.
2. Change the user's current selected tab to Deploy.

Control flow in the server-side of the Shiny app then returns to app.R. When it does, Collection Calendar returns a list of reactive values that will be passed into Deploy for the purposes of controlling Deploy when it refreshes. The list contains `deploy_refresh`, `input$collection_rows_selected`, and a variety of values from the selected row in `output$collection` [^1]

[^1]: For reasons not relevant to this example, these values are accessed through another reactive variable, `rv$collect_table_filter()`, but they are originally from the table contained in `output$collection`.


```{r collection_return, eval = FALSE}

      rv$deploy_refresh <- 0
      
      #this is a two-step observeEvent
      #when a line in the calendar is clicked, go toggle and update "smp_id_deploy", and switch tabs
      observeEvent(input$collection_rows_selected, {
        rv$deploy_refresh <- rv$deploy_refresh + 1
        updateTabsetPanel(session = parent_session, "inTabset", selected = "deploy_tab")
      })


      return(
        list(
          sensor_serial = reactive(rv$collect_table_db$sensor_serial),
          smp_id = reactive(rv$collect_table_filter()$smp_id[input$collection_rows_selected]),
          site_name = reactive(rv$collect_table_filter()$site_name[input$collection_rows_selected]),
          deploy_refresh = reactive(rv$deploy_refresh),
          rows_selected = reactive(input$collection_rows_selected),
          row = reactive(rv$collect_table_filter()$deployment_uid[input$collection_rows_selected]), 
          future_smp_id = reactive(rv$future_table_db$smp_id[input$fd_selected]), 
          future_site_name = reactive(rv$future_table_db$site_name[input$fd_selected]), 
          future_deploy_refresh = reactive(rv$future_deploy_refresh), 
          future_rows_selected = reactive(input$fd_selected), 
          future_row = reactive(rv$future_table_db$future_deployment_uid[input$fd_selected])
          )
        )

```

### Step 4: Global app.R Server - Pass Collection Calendar's output as input to Deploy

In app.R, you can see the server function calls for each module. Each server function is assigned to a variable. Modules that can send the user to other modules accept the variable of those other modules as an argument. For example, both Deploy and Add OW can send the user to Collection Calendar, so Collection Calendar accepts both `ow` and `deploy` as arguments. 

At the conclusion of the previous step, the return values from Collection Calendar are assigned to `collection_cal` in the global app.R server function. This value is then used as an input to `deployServer`, Deploy's server function. The values are assigned to the argument named `collect`. Therefore, in Deploy's server function, the outputs from Collection Calendar's server function can be referenced with `collect$foo`.

```{r eval = FALSE}

# 2.2: Server Module functions ---------------------------
    # Collection Calendar
    collection_cal <- collection_calendarServer("collection_calendar", parent_session = session,
                                 ow = ow, deploy = deploy, poolConn = poolConn)
    #Add Edit/Location
    ow <- add_owServer("add_ow", parent_session = session, smp_id = smp_id, poolConn = poolConn, deploy = deploy)
    #Add Edit/Sensor
    sensor <- add_sensorServer("add_sensor", parent_session = session, poolConn = poolConn,
                         sensor_status_lookup = sensor_status_lookup, deploy = deploy,
                         sensor_issue_lookup = sensor_issue_lookup)
    #Deploy Sensor
    deploy <- deployServer("deploy", parent_session = session, ow = ow, collect = collection_cal,
                         sensor = sensor, poolConn = poolConn, deployment_lookup = deployment_lookup,
                         srt = srt, si = special_investigations, cwl_history = cwl_history, smp_id = smp_id, 
                         sensor_issue_lookup = sensor_issue_lookup, newstyleEqual = newstyleEqual)
    #SRT
    srt <- SRTServer("srt", parent_session = session, poolConn = poolConn,
                     srt_types = srt_types, con_phase = con_phase, sys_id = sys_id, special_char_replace = special_char_replace)
    #Special Investigations
    special_investigations<- special_investigationsServer("special_investigations", parent_session = session,
                                        poolConn = poolConn, con_phase = con_phase, si_lookup = si_lookup,
                                        requested_by_lookup = requested_by_lookup, sys_id = sys_id, special_char_replace = special_char_replace)
    #History
    cwl_history <- cwl_historyServer("history", parent_session = session, poolConn = poolConn, deploy = deploy)


```

### Step 5: Deploy Server - Checking reactive inputs and updating Deploy's input variables

Control flow then passes to Deploy's server function. The Deploy server function contains several `observeEvent` calls that check each of its module communication input variables (i.e. `collect` from Collection Calendar, `ow` from Add OW, etc) for the changes to the `deploy_refresh` value. If that value has changed, Deploy knows that the variable's source module was the one that passed control flow to Deploy, and, as such, has data for Deploy to read. Deploy reads this data and populates it into Deploy's input fields. The code block below contains Collection Calendar's corresponding `observeEvent`. 

Finally, it's time for Deploy to display the data. In Deploy, the SMP ID or Site Name is the foundational value. Tables and `selectInput` functions are based on the SMP ID or Site Name. They are first reset to purge any existing selections. Then, a value is selected from the `collect` list. The length check helps Deploy know whether the data it's reading has an SMP ID or Site Name as its foundation. This causes Deploy's corresponding datatable output object (not depicted here), to update based on the new foundational value. That is to say, now that Deploy knows which SMP/Site has been selected, it can populate its datatable with the deployments from that location.

Since that table update requires a filter operation, which takes time, a delay is used to allow that filter to complete before selecting a row in Deploy's datatable output. `collect$row` is the deployment_uid of the row selected in Collection Calendar, and that is used to select the row in Deploy's datatable. Selecting a row in the deployment datatable also pre-fills most sidebar fields for easy editing.

```{r eval = FALSE}
      #upon clicking a row in collection_calendar
      observeEvent(collect$deploy_refresh(), {
        updateSelectizeInput(session, "smp_id", selected = character(0))
        updateSelectInput(session, "site_name", selected = "")
        # need to get through the initial load where length == 0 for collection calendar smp_id (is.na does not work in that case)
        # go to either smp id or site name
        if(length(collect$smp_id()) > 0){
          if(!is.na(collect$smp_id())){
          updateSelectizeInput(session, "smp_id", choices = smp_id, selected = collect$smp_id(), server = TRUE)
          }else{
          updateSelectInput(session, "site_name", selected = collect$site_name())
          }
          #delay so that the selectizeInput is updated and table is queried before it is searched by R
          delay(250,{
                  rv$active_row <- reactive(which(rv$active_table_db()$deployment_uid == collect$row(), arr.ind = TRUE))
                  dataTableProxy('current_deployment') %>% selectRows(rv$active_row())
                })
        }
      })
      
```